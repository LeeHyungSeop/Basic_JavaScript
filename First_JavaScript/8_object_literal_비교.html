<html>

    <head>

    </head>
    <body>
        
        <script>

            //////////////////////////////////////////////////////////////////////////////////
            // oject literal 비교
            const a={name: '찰스', age:20};
            const b={name: '로라', age:25};
            const c={name: '찰스', age:20};
            const d=a;
            
            console.log('a===c : '+(a===c));
            // 다르다. 왜? memory상 다른 곳에 저장되어있다
            console.log('a===d : '+(a===d));
            // 같다. 왜? d=a라는 연산이 a가 있는 곳에 d라는 이름이 붙는다.

            // 그렇다면 const a=1; const b=1; 
            // a===b : true --> 왜? a가 1을 가리키고 있고, b가 1을 가리키고 있기 때문에 true이다.

            //////////////////////////////////////////////////////////////////////////////////
            // object literal 내용 비교
            const a2={name:'찰스', age:20};
            const b2={name:'찰스', age:20};

            const cmp_ol=(_x1,_x2) => {
                if((_x1.name === _x2.name) && (_x1.age === _x2.age))
                    return true;
                else
                    return false;
            }
            console.log('com_ol(a,c) : '+cmp_ol(a,c));
            console.log('com_ol(a,c) : '+cmp_ol(a,d));

            //////////////////////////////////////////////////////////////////////////////////
            // object literal의 구조를 모를 때
            // key들의 개수가 같은지?
            // key들의 값이 같은지?

            const cmp_ol_2=(_x1,_x2) => {
                let _x1_keys=Object.keys(_x1);
                let _x2_keys=Object.keys(_x2);
                let isEqual=true;

                if(_x1_keys.length!==_x2_keys.length)
                    isEqual=false;
                
                _x1_keys=_x1_keys.sort();
                _x2_keys=_x2_keys.sort();

                _x1_keys.forEach( (elem,idx) => {
                    if(_x1_keys[idx]!==_x2_keys[idx])
                    {
                        // return false; 로 하면 안된다. 
                        // forEach기 때문에 전체함수에서 return하는 것이 아닌,
                        // arrow function에서만 return하기 때문에 다음꺼를 계속 비교하기 때문이다.
                        // 그래서 하나라도 다르면 isEqual 변수를 flag처럼 사용하여 false로 세팅.
                        isEqual=false;
                    }
                    if(_x1[_x1_keys[idx]]!==_x2[_x2_keys[idx]])
                    {
                        isEqual=false;
                    }
                }
                );

                return isEqual;
            }
            console.log('cmp_ol_2(a,b) : '+cmp_ol_2(a,b));
            console.log('cmp_ol_2(a,c) : '+cmp_ol_2(a,c));

            //////////////////////////////////////////////////////////////////////////////////


        </script>

    </body>

</html>